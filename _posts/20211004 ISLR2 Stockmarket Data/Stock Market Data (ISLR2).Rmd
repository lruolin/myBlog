---
title: "The Stock Market Data (ISLR2)"
description: |
  Predicting whether stock moves Up or Down
author:
  - name: lruolin
date: 10-07-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---

A simple exercise to understand how to run logistic regression with stock market data using tidymodels framework. 

# Learning points:

- Customizing my own functions for EDA, and using patchwork to join plots
- Fitting logistic regression, LDA and QDA on stock market data
- Visualizing ROC and comparing AUC


# Packages

```{r}
library(pacman)
p_load(ISLR2, tidyverse, tidymodels, janitor, GGally,
       workflows, yardstick, discrim, skimr, ggsci,
       patchwork, ggstatsplot)
```

# Data

This dataset consists of percentage returns for the S&P 500 stock market over 1,250 days, from the beginning of 2001 until the end of 2005.

This is slightly different from the usual initial_split method. 


```{r}
stock_market <- Smarket %>% 
  clean_names() 

head(stock_market)
glimpse(stock_market) # 1250 x 9

```

# EDA

```{r}
summary(stock_market)
```


```{r}
stock_market %>% 
  skim()

```


```{r}
stock_market %>% 
  ggpairs()
```

# A more colorful correlation matrix:

```{r}
stock_market %>% 
  ggstatsplot::ggcorrmat()
```


## A simple ggplot for factor variable (direction):

```{r}
stock_market %>% 
  ggplot(aes(direction)) +
  geom_bar(aes(fill = direction), show.legend = F) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
  scale_fill_jco() +
  theme_classic() +
  labs(title = "Direction") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.25))) +
  theme(axis.title = element_text(face = "bold"),
        axis.text.x = element_text(face = "bold"))
```

Going the extra mile to create a function:

```{r, fig.height=20}
plot_fct_boxplot <- function(var_x) {
  stock_market %>% 
  mutate(var_x_fct = factor({{var_x}})) %>%  # so that other classes can be used for plot as well
  ggplot(aes(var_x_fct)) +
  geom_bar(aes(fill = var_x_fct), show.legend = F) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
  scale_fill_jco() + # from ggsci package
  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +
  theme_classic() +
  labs(title = str_to_title(as_label(enquo(var_x))),
       x = as_label(enquo(var_x))) +
  theme(axis.title = element_text(face = "bold"),
        axis.text.x = element_text(face = "bold"))
}
```

```{r}
plot_direction <- plot_fct_boxplot(direction)

plot_year <- plot_fct_boxplot(year)

# using patchwork
plot_direction + plot_year
```

## ggplot for numerical variables - geom_freqpoly

A simple plot:

```{r}
stock_market %>% 
  ggplot(aes(lag1)) + 
  geom_freqpoly(size = 1) +
  theme_classic() +
  labs(title = "lag1") +
  theme(axis.title = element_text(face = "bold"),
        axis.text.x = element_text(face = "bold"))
  
```

A function:

```{r}
plot_many_freqpoly <- function(var_x) {

  stock_market %>% 
  ggplot(aes({{var_x}})) +
  geom_freqpoly(size = 1) +
  theme_classic() +
  labs(title = str_to_title(as_label(enquo(var_x))),
       x = as_label(enquo(var_x))) +
  theme(axis.title = element_text(face = "bold"),
        axis.text.x = element_text(face = "bold"))
}
```

```{r}
plot_many_freqpoly(lag3)
```

```{r}
# set names to loop through
num_var <- stock_market %>% 
  select(-year) %>% 
  select_if(is.numeric) %>% 
  names()

# let the iterations begin
num_var %>% 
  syms() %>%  # take strings as input and turn them into symbols
  map(function(var) plot_many_freqpoly(!!var)) %>% 
  wrap_plots() # from patchwork

```

Although these plots were seen using the skim() function, I can customise the appearance by building my own functions.

# Split data

To use 2015 data for testing

To use data prior to 2015 for training

```{r}
set.seed(2021100401)

train_data <- stock_market %>% 
                filter(!year == 2005)

test_data <- stock_market %>% 
              filter(year == 2005)
```

# Create model

```{r}
lr_model <- 
  logistic_reg() %>% 
  set_engine("glm")

```


# Create recipe 

```{r}

stock_recipe <- 
  recipe(direction ~ ., data = train_data) %>% 
  update_role(year, today, new_role = "ID")

summary(stock_recipe)
```

# Create workflow

```{r}
stock_workflow <- 
  workflow() %>% 
  add_model(lr_model) %>% 
  add_recipe(stock_recipe)

stock_workflow
```

# Fit data

```{r}
stock_fit <- 
  stock_workflow %>% 
  fit(data = train_data)
```

```{r}
stock_fit %>% 
  extract_fit_parsnip() %>% 
  tidy()
```

Smallest p-value is assoicatied with lag1, but the negative coefficient suggests that if the market had a positive return yesterday, then it is less likely to go up today. 

However, at a p-value of 0.15, the p-value is still relatively large, and there is no clear evidence of a real association vetween lag1 and direction. 

# Predict

```{r}

predict(stock_fit, test_data)

stock_augment <- 
  augment(stock_fit, test_data) %>% 
  select(year, direction, .pred_class, .pred_Down, .pred_Up)

stock_augment
```

```{r}
stock_augment %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  autoplot()

stock_augment %>% 
  roc_auc(truth = direction, .pred_Down) # 0.52

```


# Removing variables with high p-value


```{r}
stock_recipe_two_lag <- 
  recipe(direction ~ ., data = train_data) %>% 
  update_role(year, today, lag3, lag4, lag5, volume, new_role = "ID")

summary(stock_recipe_two_lag)

# update workflow

stock_workflow_update <- 
  workflow() %>% 
  add_model(lr_model) %>% 
  add_recipe(stock_recipe_two_lag)

stock_workflow_update

# fit data

stock_fit_update <- 
  stock_workflow_update %>% 
  fit(data = train_data)

stock_fit_update %>% 
  extract_fit_parsnip() %>% 
  tidy()

# predict
predict(stock_fit_update, test_data)

# augment
stock_augment_update <- 
  augment(stock_fit_update, test_data) %>% 
  select(year, direction, .pred_class, .pred_Down, .pred_Up)

stock_augment_update

# ROC curve
stock_augment_update %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  autoplot()

stock_augment_update %>% 
  roc_auc(truth = direction, .pred_Down)  # 0.558. 
```

55.8% of the daily movements were correctly predicted.

# A second model - Linear Discriminant: 

```{r}

lda_model <- 
  discrim_linear() %>% 
  set_engine("MASS")
  
```

MASS::lda() fits a model that estimates a multivariate distribution for the predictors separately for the data in each class (Gaussian with a common covariance matrix). Bayes' theorem is used to compute the probability of each class, given the predictor values.

This engine has no tuning parameters, and is used for classification. 

# Create recipe and workflow

The same recipe can be reused.

```{r}

stock_recipe_two_lag

```


```{r}

lda_workflow <- 
  workflow() %>% 
  add_model(lda_model) %>% 
  add_recipe(stock_recipe_two_lag)

```


# Fit data

```{r}
lda_fit <- 
  lda_workflow %>% 
  fit(data = train_data)

lda_fit %>% 
  extract_fit_parsnip() 

```

# Predict

```{r}
predict(lda_fit, test_data)

lda_augment <- 
  augment(lda_fit, test_data) %>% 
  select(year, direction, .pred_class, .pred_Down, .pred_Up)

lda_augment %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  autoplot()

lda_augment %>% 
  roc_auc(truth = direction, .pred_Down) # 0.558
```


# Comparing logistic regression against linear discriminant 

```{r}
log_reg_auc <- 
  stock_augment_update %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  mutate(model = "Log Regression")

lda_auc <- 
  lda_augment %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  mutate(model = "LDA")

bind_rows(log_reg_auc, lda_auc) %>% 
  ggplot(aes(x = 1-specificity,
             y = sensitivity,
             col = model)) +
  geom_path(lwd = 1.5, alpha = 0.6) +
  geom_abline(lty = 3) +
  coord_equal()  +
  labs(title = "Comparing LDA with Log Regression",
       subtitle = "The predictions are almost identical!") +
  theme_classic() +
  theme(legend.position = "top")
```

# A third model: Quadratic Discriminant Analysis

discrim_quad() defines a model that estimates a multivariate distribution for the predictors separately for the data in each class (usually Gaussian with separate covariance matrices). Bayes' theorem is used to compute the probability of each class, given the predictor values.

regularization_method	:
A character string for the type of regularized estimation. Possible values are: "diagonal", "shrink_cov", and "shrink_mean" (sparsediscrim engine only).

```{r}
qda_mod <-
  discrim_quad() %>%
  set_engine("MASS")
```

# Recipe

I used the same recipe

```{r}
stock_recipe_two_lag
```


# Workflow

```{r}
qda_workflow <- 
  workflow() %>% 
  add_model(qda_mod) %>% 
  add_recipe(stock_recipe_two_lag)
```

# Fit data

```{r}
qda_fit <- 
  qda_workflow %>% 
  fit(data = train_data)

qda_fit %>% 
  extract_fit_parsnip()
```


# Predict

```{r}
predict(qda_fit, test_data)

qda_augment <- 
  augment(qda_fit, test_data) %>% 
  select(year, direction, .pred_class, .pred_Down, .pred_Up)

qda_augment %>% 
  roc_auc(truth = direction, .pred_Down) # 0.562

qda_auc <- 
  qda_augment %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  mutate(model = "QDA")


```

# Comparing against the first two models

Comparing AUC:

```{r}
auc_log <- stock_augment_update %>% 
  roc_auc(truth = direction, .pred_Down) %>% 
  mutate(model = "Log Reg")

auc_lda <- lda_augment %>% 
  roc_auc(truth = direction, .pred_Down) %>% 
  mutate(model = "LDA")

auc_qda <- qda_augment %>% 
  roc_auc(truth = direction, .pred_Down) %>% 
  mutate(model = "QDA")

bind_rows(auc_log, auc_lda, auc_qda)
```

ROC plot:

```{r}
bind_rows(log_reg_auc, 
          lda_auc,
          qda_auc) %>% 
  ggplot(aes(x = 1-specificity,
             y = sensitivity,
             col = model)) +
  geom_path(lwd = 1.5, alpha = 0.8) +
  geom_abline(lty = 3) +
  coord_equal()  +
  labs(title = "Comparing QDA, LDA and Log Regression",
       subtitle = "QDA is very slightly better than the other two models!") +
  scale_color_jco() +
  theme_classic() +
  theme(legend.position = "top")
```



# Reference:

- [ISLR2 book] (https://web.stanford.edu/~hastie/ISLRv2_website.pdf)

- <https://www.tidymodels.org/start/recipes/>

- <https://discrim.tidymodels.org/reference/discrim_linear.html>

- <https://discrim.tidymodels.org/reference/discrim_quad.html>