---
title: "Data visualization with ggplot2"
description: |
  R4DS 01 - Data visualization with ggplot 2
author:
  - name: lruolin
date: 04-24-2021
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# R4DS Practice 01: Data visualization with ggplot 2

The codes below are from the practice exercises in <https://r4ds.had.co.nz/>, and are taken with reference from: <https://jrnold.github.io/r4ds-exercise-solutions/>

# Let's begin now

Loading tidyverse package
```{r}
library(tidyverse)
```

Loading mpg data frame:
mpg dataset is the fuel economy data from 1999 to 2008 for 38 popular models of cars.
This dataset contains a subset of the fuel economy data that the EPA makes available on https://fueleconomy.gov/. It contains only models which had a new release every year between 1999 and 2008 - this was used as a proxy for the popularity of the car.


```{r}
mpg
```
Creating a ggplot:

```{r}

mpg %>%  # this is the pipe operator
  ggplot(aes(x = displ, y = hwy)) +  # variable names within aes(); use + and not %>%
  geom_point() # type of plot
```

There is a negative relationship between engine size (displ) and fuel efficiency (hwy).

The bigger the engine size, the lower the fuel efficiency, the more fuel they use. 

```{r}
ggplot(mpg) # this returns a blank
```

How many rows are there in the mpg dataset?

```{r}
glimpse(mpg)
```

There are 234 rows and 11 columns.

What does the drv variable describe?

```{r}
?mpg
```

The drv variable describes the type of drive train:

- f = front wheel drive
- r = rear wheel drive
- 4 = 4 wheel drive

Make a scatterplot of hwy vs cyl

```{r}
mpg %>% 
  ggplot(aes(x = cyl, y = hwy)) +
  geom_point()
```

What happens if you make a scatterplot of class vs drv?

drv: type of drive train
class: type of car


```{r}
mpg %>% 
  ggplot(aes(class, drv)) +
  geom_point()
```

A scatter-plot is more suitable for visualizaing relationships between continuous x and continuous y data, hence is not suitable for categorical x and categorical y. 

# Adding colors to the variable

To see if the cars that fall outside the linear trend, which have a higher mileage than expected, are hybrid cars.

```{r}

mpg %>% 
  ggplot(aes(displ, hwy, col = class)) + # adding color according to the class variable
  geom_point() +
  theme_classic() # changing the theme
```

```{r}
glimpse(mpg)
```

Continuous variables are those that are numerical. Categorical are those that have <chr>. 

```{r}
# values in cyl col:

mpg %>% 
  select(cyl) %>% 
  unique()
```


However, discrete continuous variables may also be categorical, eg for cyl (number of cylinders), the values are 4, 5, 6, 8. 

Continuous variables, when mapped to color, will take on different hues of the colour. 
When mapped to size, the size of the point will vary according to the value.
When mapped to shape, there will be an error.

```{r}

# continuous variable cty mapped to color
mpg %>% 
  ggplot(aes(displ, hwy, col = cty)) + # cty = city miles per gallon
  geom_point()

# continuous variable cty mapped to size
mpg %>% 
  ggplot(aes(displ, hwy, size = cty)) + # cty = city miles per gallon
  geom_point()

# continuous variable cty mapped to color and size
mpg %>% 
  ggplot(aes(displ, hwy, col = cty, size = cty)) + # cty = city miles per gallon
  geom_point()


```

What does the stroke aesthetic do? It changes the size of the border for shapes 21 - 25, which are the filled shapes. 

```{r}
mpg %>% 
  ggplot(aes(displ, hwy)) +
  geom_point(shape = 24, stroke = 1 )

mpg %>% 
  ggplot(aes(displ, hwy)) +
  geom_point(shape = 24, stroke = 5)
```
What happens if you want to map an aesthetic to something other than a variable name, like aes(col = displ < 5)?

```{r}
mpg %>% 
  ggplot(aes(displ, hwy)) +
  geom_point(aes(col = displ<5)) + # a temporary variable will be added to the data for plotting
  theme_classic()
```

## Faceting

Faceting is useful to split the plot by categories. 
You will still need to define the dataset, the ggplot command, the type of plot (geom_point) and then use facet_wrap. 

facet_wrap:

```{r}
glimpse(mpg) 

# categorical variables may be manufacturer, model

mpg %>% 
  ggplot(aes(displ, hwy)) +
  geom_point() +
  facet_wrap( ~ class, nrow = 2) # facet wrap ( row ~ col, number of rows = 2)
```

facet_grid: facet_grid() forms a matrix of panels defined by row and column faceting variables. It is most useful when you have two discrete variables, and all combinations of the variables exist in the data. If you have only one variable with many levels, try facet_wrap().

```{r}
mpg %>% 
  ggplot(aes(displ, hwy)) +
  geom_point() +
  facet_grid(drv ~cyl)
```

Faceting is not recommended for continuous variable since each panel will be a unique value of the continuous variable.

Empty cells mean that there is no observation in that plot.

What plots do the following codes make?

The dot is used as a placeholder. 

```{r}
mpg %>% 
  ggplot(aes(displ, hwy)) +
  geom_point(aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)


mpg %>% 
  ggplot(aes(displ, hwy)) +
  geom_point(aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)
```

```{r}
mpg %>% 
  ggplot(aes(x = displ, y = hwy)) + 
  geom_point() +
  facet_wrap( ~ class, nrow = 2)
```
# Geometric objects

```{r}
mpg %>% 
  ggplot(aes(x = displ, y = hwy)) +
  geom_smooth(aes(linetype = drv))
```
```{r}
mpg %>% 
  ggplot(aes(displ, hwy, col = drv)) +
  geom_smooth()
```

Recreating R plots:

```{r}
mpg %>% 
  ggplot(aes(x = displ, y = hwy)) +
  geom_smooth(se = F) +
  geom_point()
  
mpg %>% 
  ggplot(aes(x = displ, y = hwy)) +
  geom_smooth(aes(group = drv), se = F) +
  geom_point()

mpg %>% 
  ggplot(aes(x = displ, y = hwy)) +
  geom_smooth(aes(group = drv, col = drv), se = F) +
  geom_point(aes(col = drv))

mpg %>% 
  ggplot(aes(x = displ, y = hwy)) +
  geom_smooth( se = F) +
  geom_point(aes(col= drv))

mpg %>% 
  ggplot(aes(x = displ, y = hwy)) +
  geom_smooth(aes(linetype = drv), se = F) +
  geom_point(aes(col = drv))

mpg %>% 
  ggplot(aes(displ, hwy)) +
  geom_point(size = 4, col = "white") +
  geom_point(aes(col = drv))

```

# Statistical transformation, diamonds dataset

```{r}
diamonds %>% 
  ggplot(aes(cut)) +
  geom_bar() +
  labs(title = "Count of diamonds for various cuts") +
  theme_classic()
```


Overiding the default mapping - to display a bar chart of proportion rather than count

```{r}
diamonds %>% 
  ggplot(aes(cut)) +
  geom_bar(mapping = aes(cut, y = ..prop.. , group = 1))
```

```{r}
ggplot(data = diamonds) +
  stat_summary(
    mapping = aes( x = cut, y = depth),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  ) +
  theme_classic()
```

Position adjustments: Stacked bar chart

```{r}
diamonds %>% 
  ggplot(aes(x = cut)) +
  geom_bar(aes(fill = clarity)) +
  theme_classic()

# to compare proportions across groups
diamonds %>% 
  ggplot(aes(x = cut)) +
  geom_bar(aes(fill = clarity), position = "fill") +
  theme_classic()

# to compare proportions across groups
diamonds %>% 
  ggplot(aes(x = cut)) +
  geom_bar(aes(fill = clarity), position = "dodge") + # to compare individual values
  theme_classic()
```

For geom_boxplot, the default position is position_dodge2 (moves the geom horizontally to avoid overlapping other geoms.)

```{r}
mpg %>% 
  ggplot(aes(drv, hwy, col= class)) +
  geom_boxplot() +
  theme_classic()
```

# Notes:

This first chapter of R4DS is aimed at giving a basic and gentle introduction to the ggplot workflow. The main points are to remember to define the dataframe, to remember to add aes() for defining the variables, and to use + and not %>% for each new line in ggplot2. There are many geom objects (boxplot, barplot etc) which are available in the cheatsheet. There are also various ways to change the appearance of the plot and I like how easy it is to change the colors. The title, subtitle and axis titles may be changed using the labs() function. It is a bit different from the Excel workflow which allows you to point and click, but for ggplot2 you can only change the appearance one layer by one layer, and may take a while to get used to, but I appreciate the convenience of using commands rather than clicking of mouse, and the scalability in which I can put in new data and run all of the commands to generate the same plot. 





# Reference
<https://r4ds.had.co.nz/>

<https://jrnold.github.io/r4ds-exercise-solutions/>