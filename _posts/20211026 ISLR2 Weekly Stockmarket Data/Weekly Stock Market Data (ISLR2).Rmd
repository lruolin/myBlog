---
title: "Weekly Stock Market Data (ISLR2)"
description: |
  Predicting whether stock moves Up or Down
author:
  - name: lruolin
date: 10-27-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---

A simple exercise to understand how to run logistic regression with stock market data using tidymodels framework, using the weekly dataset.

# Learning points:

- Customizing my own functions for EDA, and using patchwork to join plots
- Fitting logistic regression, LDA and QDA on stock market data
- Visualizing ROC and comparing AUC


# Packages

```{r}
library(pacman)
p_load(ISLR2, tidyverse, tidymodels, janitor, GGally,
       workflows, yardstick, discrim, skimr, ggsci,
       patchwork, ggstatsplot)
```

# Data

This dataset consists of 1,089 weekly returns for 21 years, from the beginning of 1990 to end of 2010. 


```{r}
stock_market <- Weekly %>% 
  clean_names() 

head(stock_market)
glimpse(stock_market) # 1,089 x 9

```

# EDA

```{r}
summary(stock_market)
```


```{r}
stock_market %>% 
  skim()

```


```{r}
stock_market %>% 
  ggpairs()
```

# A more colorful correlation matrix:

```{r}
stock_market %>% 
  ggstatsplot::ggcorrmat()
```

Not much correlation except between volume and today. 

## A simple ggplot for factor variable (direction):

This plot shows the proportion
```{r}
stock_market %>% 
  group_by(direction) %>% 
  summarize(n = n(), .groups = "drop") %>% 
  mutate(prop = n/sum(n)) %>% 
  ggplot(aes(direction, prop, label = scales::percent(prop))) +
  geom_col(aes(fill = direction), show.legend = F) +
  geom_text(vjust = -1) + 
  scale_fill_jco() +
  theme_classic() +
  labs(title = "Direction") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.25))) +
  theme(axis.title = element_text(face = "bold"),
        axis.text.x = element_text(face = "bold"))
```


## ggplot for numerical variables - geom_freqpoly

A simple plot:

```{r}
stock_market %>% 
  ggplot(aes(lag1)) + 
  geom_freqpoly(size = 1) +
  theme_classic() +
  labs(title = "lag1") +
  theme(axis.title = element_text(face = "bold"),
        axis.text.x = element_text(face = "bold"))
  
```

A function:

```{r}
plot_many_freqpoly <- function(var_x) {

  stock_market %>% 
  ggplot(aes({{var_x}})) +
  geom_freqpoly(size = 1) +
  theme_classic() +
  labs(title = str_to_title(as_label(enquo(var_x))),
       x = as_label(enquo(var_x))) +
  theme(axis.title = element_text(face = "bold"),
        axis.text.x = element_text(face = "bold"))
}
```

```{r}
plot_many_freqpoly(lag3)
```

```{r}
# set names to loop through
num_var <- stock_market %>% 
  select(-year) %>% 
  select_if(is.numeric) %>% 
  names()

# let the iterations begin
num_var %>% 
  syms() %>%  # take strings as input and turn them into symbols
  map(function(var) plot_many_freqpoly({{var}})) %>% 
  wrap_plots() # from patchwork

```

Although these plots were seen using the skim() function, I can customise the appearance by building my own functions.

## Plot of change in volume against year

```{r}
head(stock_market)

min(stock_market$year) # 1990
max(stock_market$year) # 2010

stock_market %>% 
  group_by(year) %>% 
  count() %>% 
  filter(n !=52)

lubridate::leap_year(1996) # T, 53w
lubridate::leap_year(2007) # F, 53w
lubridate::leap_year(1990) # F, 47w
```

The years 1990, 1996 and 2007 do not have 52 sets of data.
All other years from 1991 - 2010 do

```{r}
library(tsibble)

seq(1990:2010)
w90 <- rep(1:47) %>% 
  as_tibble()

w90

w91_95 <- rep(1:52, times = 5) %>% 
  as_tibble()

w96 <- rep(1:53) %>% 
  as_tibble()

w97_06 <- rep(1:52, times = 10) %>% 
  as_tibble()

w07 <- w96

w08_10 <- rep(1:52, times = 3) %>% 
  as_tibble()

weeks <- bind_rows(w90,
                   w91_95,
                   w96,
                   w97_06,
                   w07,
                   w08_10) %>% 
  rename(week_no = value)

stock_market_wk <- stock_market %>% 
  bind_cols(weeks)

glimpse(stock_market_wk)
```



# Split data

To use 2015 data for testing

To use data prior to 2015 for training

```{r}
set.seed(2021100401)

train_data <- stock_market %>% 
                filter(!year == 2005)

test_data <- stock_market %>% 
              filter(year == 2005)
```

# Create model

```{r}
lr_model <- 
  logistic_reg() %>% 
  set_engine("glm")

```


# Create recipe 

```{r}

stock_recipe <- 
  recipe(direction ~ ., data = train_data) %>% 
  update_role(year, today, new_role = "ID")

summary(stock_recipe)
```

# Create workflow

```{r}
stock_workflow <- 
  workflow() %>% 
  add_model(lr_model) %>% 
  add_recipe(stock_recipe)

stock_workflow
```

# Fit data

```{r}
stock_fit <- 
  stock_workflow %>% 
  fit(data = train_data)
```

```{r}
stock_fit %>% 
  extract_fit_parsnip() %>% 
  tidy()
```

Smallest p-value is assoicatied with lag1, but the negative coefficient suggests that if the market had a positive return yesterday, then it is less likely to go up today. 

However, at a p-value of 0.15, the p-value is still relatively large, and there is no clear evidence of a real association vetween lag1 and direction. 

# Predict

```{r}

predict(stock_fit, test_data)

stock_augment <- 
  augment(stock_fit, test_data) %>% 
  select(year, direction, .pred_class, .pred_Down, .pred_Up)

stock_augment
```

```{r}
stock_augment %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  autoplot()

stock_augment %>% 
  roc_auc(truth = direction, .pred_Down) # 0.52

```


# Removing variables with high p-value


```{r}
stock_recipe_two_lag <- 
  recipe(direction ~ ., data = train_data) %>% 
  update_role(year, today, lag3, lag4, lag5, volume, new_role = "ID")

summary(stock_recipe_two_lag)

# update workflow

stock_workflow_update <- 
  workflow() %>% 
  add_model(lr_model) %>% 
  add_recipe(stock_recipe_two_lag)

stock_workflow_update

# fit data

stock_fit_update <- 
  stock_workflow_update %>% 
  fit(data = train_data)

stock_fit_update %>% 
  extract_fit_parsnip() %>% 
  tidy()

# predict
predict(stock_fit_update, test_data)

# augment
stock_augment_update <- 
  augment(stock_fit_update, test_data) %>% 
  select(year, direction, .pred_class, .pred_Down, .pred_Up)

stock_augment_update

# ROC curve
stock_augment_update %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  autoplot()

stock_augment_update %>% 
  roc_auc(truth = direction, .pred_Down)  # 0.558. 
```

55.8% of the daily movements were correctly predicted.

# A second model - Linear Discriminant: 

```{r}

lda_model <- 
  discrim_linear() %>% 
  set_engine("MASS")
  
```

MASS::lda() fits a model that estimates a multivariate distribution for the predictors separately for the data in each class (Gaussian with a common covariance matrix). Bayes' theorem is used to compute the probability of each class, given the predictor values.

This engine has no tuning parameters, and is used for classification. 

# Create recipe and workflow

The same recipe can be reused.

```{r}

stock_recipe_two_lag

```


```{r}

lda_workflow <- 
  workflow() %>% 
  add_model(lda_model) %>% 
  add_recipe(stock_recipe_two_lag)

```


# Fit data

```{r}
lda_fit <- 
  lda_workflow %>% 
  fit(data = train_data)

lda_fit %>% 
  extract_fit_parsnip() 

```

# Predict

```{r}
predict(lda_fit, test_data)

lda_augment <- 
  augment(lda_fit, test_data) %>% 
  select(year, direction, .pred_class, .pred_Down, .pred_Up)

lda_augment %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  autoplot()

lda_augment %>% 
  roc_auc(truth = direction, .pred_Down) # 0.558
```


# Comparing logistic regression against linear discriminant 

```{r}
log_reg_auc <- 
  stock_augment_update %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  mutate(model = "Log Regression")

lda_auc <- 
  lda_augment %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  mutate(model = "LDA")

bind_rows(log_reg_auc, lda_auc) %>% 
  ggplot(aes(x = 1-specificity,
             y = sensitivity,
             col = model)) +
  geom_path(lwd = 1.5, alpha = 0.6) +
  geom_abline(lty = 3) +
  coord_equal()  +
  labs(title = "Comparing LDA with Log Regression",
       subtitle = "The predictions are almost identical!") +
  theme_classic() +
  theme(legend.position = "top")
```

# A third model: Quadratic Discriminant Analysis

discrim_quad() defines a model that estimates a multivariate distribution for the predictors separately for the data in each class (usually Gaussian with separate covariance matrices). Bayes' theorem is used to compute the probability of each class, given the predictor values.

regularization_method	:
A character string for the type of regularized estimation. Possible values are: "diagonal", "shrink_cov", and "shrink_mean" (sparsediscrim engine only).

```{r}
qda_mod <-
  discrim_quad() %>%
  set_engine("MASS")
```

# Recipe

I used the same recipe

```{r}
stock_recipe_two_lag
```


# Workflow

```{r}
qda_workflow <- 
  workflow() %>% 
  add_model(qda_mod) %>% 
  add_recipe(stock_recipe_two_lag)
```

# Fit data

```{r}
qda_fit <- 
  qda_workflow %>% 
  fit(data = train_data)

qda_fit %>% 
  extract_fit_parsnip()
```


# Predict

```{r}
predict(qda_fit, test_data)

qda_augment <- 
  augment(qda_fit, test_data) %>% 
  select(year, direction, .pred_class, .pred_Down, .pred_Up)

qda_augment %>% 
  roc_auc(truth = direction, .pred_Down) # 0.562

qda_auc <- 
  qda_augment %>% 
  roc_curve(truth = direction, .pred_Down) %>% 
  mutate(model = "QDA")


```

# Comparing against the first two models

Comparing AUC:

```{r}
auc_log <- stock_augment_update %>% 
  roc_auc(truth = direction, .pred_Down) %>% 
  mutate(model = "Log Reg")

auc_lda <- lda_augment %>% 
  roc_auc(truth = direction, .pred_Down) %>% 
  mutate(model = "LDA")

auc_qda <- qda_augment %>% 
  roc_auc(truth = direction, .pred_Down) %>% 
  mutate(model = "QDA")

bind_rows(auc_log, auc_lda, auc_qda)
```

ROC plot:

```{r}
bind_rows(log_reg_auc, 
          lda_auc,
          qda_auc) %>% 
  ggplot(aes(x = 1-specificity,
             y = sensitivity,
             col = model)) +
  geom_path(lwd = 1.5, alpha = 0.8) +
  geom_abline(lty = 3) +
  coord_equal()  +
  labs(title = "Comparing QDA, LDA and Log Regression",
       subtitle = "QDA is very slightly better than the other two models!") +
  scale_color_jco() +
  theme_classic() +
  theme(legend.position = "top")
```



# Reference:

- [ISLR2 book] (https://web.stanford.edu/~hastie/ISLRv2_website.pdf)

- <https://www.tidymodels.org/start/recipes/>

- <https://discrim.tidymodels.org/reference/discrim_linear.html>

- <https://discrim.tidymodels.org/reference/discrim_quad.html>