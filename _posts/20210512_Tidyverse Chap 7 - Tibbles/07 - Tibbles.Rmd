---
title: "Data Import"
description: |
  R4DS 08 - Data Import with readr
author:
  - name: lruolin
date: 05-14-2021
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# R4DS Practice 08: Data Import

The codes below are from the practice exercises in <https://r4ds.had.co.nz/>, and are taken with reference from: <https://jrnold.github.io/r4ds-exercise-solutions/>

# Let's begin now

Loading tidyverse package. 

```{r}
library(tidyverse)
```

# Introduction

This chapter is about importing data (plain text rectangular files) into R. 

A cheatsheet is available at: <https://readr.tidyverse.org/>

## Importing in csv file:

It is important to define the path to the file to read. The data below is a dataset from tidytuesday, and the data was scrapped from [fastfoodnutrition.org](https://fastfoodnutrition.org/). 

```{r}
# Importing Fast Food Data from

calories <- read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-09-04/fastfood_calories.csv")

glimpse(calories)
```

To read a file where the fields are separated by "|", use the read_delim() function, and specify the delimiter. 

For read_csv(), you can also use trim_ws to trim the whitespace before and after cells, indicate the locale, specify what to do with NA, and show the progress bar if needed. 

To read the following:

```{r}
x <- "x, y\n1, `a, b`"
read_csv(x, quote = "`")


```

Identify what is wrong with each of the following inline CSV files:

```{r}
read_csv("a, b\n1,2,3\n4,5,6")

# only 2 columns have headers specified but there should be three column headers

```


```{r}
read_csv("a,b,c\n1,2\n1,2,3,4")

# the number of columns in data do not match number of columns in headers
```

```{r}
read_csv("a,b\n\"1")

# the number of quotation marks are not correct
```

```{r}
read_csv("a,b\n1,2\na,b")

# col a had a value of a?
```
```{r}
read_csv("a;b\n1;3") # delimiter is ;, use read_csv2

read_csv2("a;b\n1;3")
```

# Parsing a vector

The important arguments to locale are:

locale(
  date_names = "en",
  date_format = "%AD",
  time_format = "%AT",
  decimal_mark = ".",
  grouping_mark = ",",
  tz = "UTC",
  encoding = "UTF-8",
  asciify = FALSE
)

**Arguments**: 

**date_names**	
Character representations of day and month names. Either the language code as string (passed on to date_names_lang()) or an object created by date_names().

**date_format, time_format**	
Default date and time formats.

**decimal_mark, grouping_mark**	
Symbols used to indicate the decimal place, and to chunk larger numbers. Decimal mark can only be , or ..

**tz**	
Default tz. This is used both for input (if the time zone isn't present in individual strings), and for output (to control the default display). The default is to use "UTC", a time zone that does not use daylight savings time (DST) and hence is typically most useful for data. The absence of time zones makes it approximately 50x faster to generate UTC times than any other time zone.

Use "" to use the system default time zone, but beware that this will not be reproducible across systems.

For a complete list of possible time zones, see OlsonNames(). Americans, note that "EST" is a Canadian time zone that does not have DST. It is not Eastern Standard Time. It's better to use "US/Eastern", "US/Central" etc.

**encoding**	
Default encoding. This only affects how the file is read - readr always converts the output to UTF-8.

**asciify**	
Should diacritics be stripped from date names and converted to ASCII? This is useful if you're dealing with ASCII data where the correct spellings have been lost. Requires the stringi package


Generate the correct format string to parse each of the following dates and times:

```{r}
d1 <- "January 1, 2010"

parse_date(d1, "%B %d, %Y")

#
d2 <- "2015-Mar-07"

parse_date(d2, "%Y-%b-%d")

#
d3 <- "06-Jun-2017"

parse_date(d3, "%d-%b-%Y")

#
d4 <- c("August 19 (2015)", "July 1 (2015)")
parse_date(d4, "%B %d (%Y)")

#
d5 <- "12/03/14" # Dec 30, 2014
parse_date(d5, "%m/%d/%y")

#
t1 <- "1705"
parse_time(t1, "%H%M")

#
t2 <- "11:15:10.12 PM"
parse_time(t2, "%H:%M:%OS %p")

```



# datapasta

# Reference
<https://r4ds.had.co.nz/>

<https://jrnold.github.io/r4ds-exercise-solutions/>

<https://rpubs.com/LaurynKeller/662242>

